// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/rabbitmq/cluster-operator/api/v1beta1

package v1beta1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
	appsv1 "k8s.io/api/apps/v1"
	k8sresource "k8s.io/apimachinery/pkg/api/resource"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="AllReplicasReady",type="string",JSONPath=".status.conditions[?(@.type == 'AllReplicasReady')].status"
// +kubebuilder:printcolumn:name="ReconcileSuccess",type="string",JSONPath=".status.conditions[?(@.type == 'ReconcileSuccess')].status"
// +kubebuilder:printcolumn:name="Age",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:shortName={"rmq"},categories=all;rabbitmq
// RabbitmqCluster is the Schema for the RabbitmqCluster API. Each instance of this object
// corresponds to a single RabbitMQ cluster.
#RabbitmqCluster: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec is the desired state of the RabbitmqCluster Custom Resource.
	spec?: #RabbitmqClusterSpec @go(Spec)

	// Status presents the observed state of RabbitmqCluster
	status?: #RabbitmqClusterStatus @go(Status)
}

// Spec is the desired state of the RabbitmqCluster Custom Resource.
#RabbitmqClusterSpec: {
	// Replicas is the number of nodes in the RabbitMQ cluster. Each node is deployed as a Replica in a StatefulSet. Only 1, 3, 5 replicas clusters are tested.
	// This value should be an odd number to ensure the resultant cluster can establish exactly one quorum of nodes
	// in the event of a fragmenting network partition.
	// +optional
	// +kubebuilder:validation:Minimum:=0
	// +kubebuilder:default:=1
	replicas?: null | int32 @go(Replicas,*int32)

	// Image is the name of the RabbitMQ docker image to use for RabbitMQ nodes in the RabbitmqCluster.
	// Must be provided together with ImagePullSecrets in order to use an image in a private registry.
	image?: string @go(Image)

	// List of Secret resource containing access credentials to the registry for the RabbitMQ image. Required if the docker registry is private.
	imagePullSecrets?: [...corev1.#LocalObjectReference] @go(ImagePullSecrets,[]corev1.LocalObjectReference)

	// The desired state of the Kubernetes Service to create for the cluster.
	// +kubebuilder:default:={type: "ClusterIP"}
	service?: #RabbitmqClusterServiceSpec @go(Service)

	// The desired persistent storage configuration for each Pod in the cluster.
	// +kubebuilder:default:={storage: "10Gi"}
	persistence?: #RabbitmqClusterPersistenceSpec @go(Persistence)

	// The desired compute resource requirements of Pods in the cluster.
	// +kubebuilder:default:={limits: {cpu: "2000m", memory: "2Gi"}, requests: {cpu: "1000m", memory: "2Gi"}}
	resources?: null | corev1.#ResourceRequirements @go(Resources,*corev1.ResourceRequirements)

	// Affinity scheduling rules to be applied on created Pods.
	affinity?: null | corev1.#Affinity @go(Affinity,*corev1.Affinity)

	// Tolerations is the list of Toleration resources attached to each Pod in the RabbitmqCluster.
	tolerations?: [...corev1.#Toleration] @go(Tolerations,[]corev1.Toleration)

	// Configuration options for RabbitMQ Pods created in the cluster.
	rabbitmq?: #RabbitmqClusterConfigurationSpec @go(Rabbitmq)

	// TLS-related configuration for the RabbitMQ cluster.
	tls?: #TLSSpec @go(TLS)

	// Provides the ability to override the generated manifest of several child resources.
	override?: #RabbitmqClusterOverrideSpec @go(Override)

	// If unset, or set to false, the cluster will run `rabbitmq-queues rebalance all` whenever the cluster is updated.
	// Set to true to prevent the operator rebalancing queue leaders after a cluster update.
	// Has no effect if the cluster only consists of one node.
	// For more information, see https://www.rabbitmq.com/rabbitmq-queues.8.html#rebalance
	skipPostDeploySteps?: bool @go(SkipPostDeploySteps)

	// TerminationGracePeriodSeconds is the timeout that each rabbitmqcluster pod will have to terminate gracefully.
	// It defaults to 604800 seconds ( a week long) to ensure that the container preStop lifecycle hook can finish running.
	// For more information, see: https://github.com/rabbitmq/cluster-operator/blob/main/docs/design/20200520-graceful-pod-termination.md
	// +kubebuilder:validation:Minimum:=0
	// +kubebuilder:default:=604800
	terminationGracePeriodSeconds?: null | int64 @go(TerminationGracePeriodSeconds,*int64)

	// Secret backend configuration for the RabbitmqCluster.
	// Enables to fetch default user credentials and certificates from K8s external secret stores.
	secretBackend?: #SecretBackend @go(SecretBackend)
}

// SecretBackend configures a single secret backend.
// Today, only Vault exists as supported secret backend.
// Future secret backends could be Secrets Store CSI Driver.
// If not configured, K8s Secrets will be used.
#SecretBackend: {
	vault?: null | #VaultSpec @go(Vault,*VaultSpec)
}

// VaultSpec will add Vault annotations (see https://www.vaultproject.io/docs/platform/k8s/injector/annotations)
// to RabbitMQ Pods. It requires a Vault Agent Sidecar Injector (https://www.vaultproject.io/docs/platform/k8s/injector)
// to be installed in the K8s cluster. The injector is a K8s Mutation Webhook Controller that alters RabbitMQ Pod specifications
// (based on the added Vault annotations) to include Vault Agent containers that render Vault secrets to the volume.
#VaultSpec: {
	// Role in Vault.
	// If vault.defaultUserPath is set, this role must have capability to read the pre-created default user credential in Vault.
	// If vault.tls is set, this role must have capability to create and update certificates in the Vault PKI engine for the domains
	// "<namespace>" and "<namespace>.svc".
	role?: string @go(Role)

	// Vault annotations that override the Vault annotations set by the cluster-operator.
	// For a list of valid Vault annotations, see https://www.vaultproject.io/docs/platform/k8s/injector/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string)

	// Path in Vault to access a KV (Key-Value) secret with the fields username and password for the default user.
	// For example "secret/data/rabbitmq/config".
	defaultUserPath?: string @go(DefaultUserPath)

	// Sidecar container that updates the default user's password in RabbitMQ when it changes in Vault.
	// Additionally, it updates /var/lib/rabbitmq/.rabbitmqadmin.conf (used by rabbitmqadmin CLI).
	// Set to empty string to disable the sidecar container.
	defaultUserUpdaterImage?: null | string @go(DefaultUserUpdaterImage,*string)
	tls?:                     #VaultTLSSpec @go(TLS)
}

#VaultTLSSpec: {
	// Path in Vault PKI engine.
	// For example "pki/issue/hashicorp-com".
	// required
	pkiIssuerPath?: string @go(PKIIssuerPath)

	// Specifies the requested certificate Common Name (CN).
	// Defaults to <serviceName>.<namespace>.svc if not provided.
	// +optional
	commonName?: string @go(CommonName)

	// Specifies the requested Subject Alternative Names (SANs), in a comma-delimited list.
	// These will be appended to the SANs added by the cluster-operator.
	// The cluster-operator will add SANs:
	// "<RabbitmqCluster name>-server-<index>.<RabbitmqCluster name>-nodes.<namespace>" for each pod,
	// e.g. "myrabbit-server-0.myrabbit-nodes.default".
	// +optional
	altNames?: string @go(AltNames)

	// Specifies the requested IP Subject Alternative Names, in a comma-delimited list.
	// +optional
	ipSans?: string @go(IpSans)
}

// Provides the ability to override the generated manifest of several child resources.
#RabbitmqClusterOverrideSpec: {
	// Override configuration for the RabbitMQ StatefulSet.
	statefulSet?: null | #StatefulSet @go(StatefulSet,*StatefulSet)

	// Override configuration for the Service created to serve traffic to the cluster.
	service?: null | #Service @go(Service,*Service)
}

// Override configuration for the Service created to serve traffic to the cluster.
// Allows for the manifest of the created Service to be overwritten with custom configuration.
#Service: {
	// +optional
	metadata?: null | #EmbeddedLabelsAnnotations @go(EmbeddedLabelsAnnotations,*EmbeddedLabelsAnnotations) @protobuf(1,bytes,opt)

	// Spec defines the behavior of a Service.
	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: null | corev1.#ServiceSpec @go(Spec,*corev1.ServiceSpec) @protobuf(2,bytes,opt)
}

// Override configuration for the RabbitMQ StatefulSet.
// Allows for the manifest of the created StatefulSet to be overwritten with custom configuration.
#StatefulSet: {
	// +optional
	metadata?: null | #EmbeddedLabelsAnnotations @go(EmbeddedLabelsAnnotations,*EmbeddedLabelsAnnotations) @protobuf(1,bytes,opt)

	// Spec defines the desired identities of pods in this set.
	// +optional
	spec?: null | #StatefulSetSpec @go(Spec,*StatefulSetSpec) @protobuf(2,bytes,opt)
}

// StatefulSetSpec contains a subset of the fields included in k8s.io/api/apps/v1.StatefulSetSpec.
// Field RevisionHistoryLimit is omitted.
// Every field is made optional.
#StatefulSetSpec: {
	// replicas corresponds to the desired number of Pods in the StatefulSet.
	// For more info, see https://pkg.go.dev/k8s.io/api/apps/v1#StatefulSetSpec
	// +optional
	replicas?: null | int32 @go(Replicas,*int32) @protobuf(1,varint,opt)

	// selector is a label query over pods that should match the replica count.
	// It must match the pod template's labels.
	// More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
	// +optional
	selector?: null | metav1.#LabelSelector @go(Selector,*metav1.LabelSelector) @protobuf(2,bytes,opt)

	// template is the object that describes the pod that will be created if
	// insufficient replicas are detected. Each pod stamped out by the StatefulSet
	// will fulfill this Template, but have a unique identity from the rest
	// of the StatefulSet.
	// +optional
	template?: null | #PodTemplateSpec @go(Template,*PodTemplateSpec) @protobuf(3,bytes,opt)

	// volumeClaimTemplates is a list of claims that pods are allowed to reference.
	// The StatefulSet controller is responsible for mapping network identities to
	// claims in a way that maintains the identity of a pod. Every claim in
	// this list must have at least one matching (by name) volumeMount in one
	// container in the template. A claim in this list takes precedence over
	// any volumes in the template, with the same name.
	// +optional
	volumeClaimTemplates?: [...#PersistentVolumeClaim] @go(VolumeClaimTemplates,[]PersistentVolumeClaim) @protobuf(4,bytes,rep)

	// serviceName is the name of the service that governs this StatefulSet.
	// This service must exist before the StatefulSet, and is responsible for
	// the network identity of the set. Pods get DNS/hostnames that follow the
	// pattern: pod-specific-string.serviceName.default.svc.cluster.local
	// where "pod-specific-string" is managed by the StatefulSet controller.
	// +optional
	serviceName?: string @go(ServiceName) @protobuf(5,bytes,opt)

	// podManagementPolicy controls how pods are created during initial scale up,
	// when replacing pods on nodes, or when scaling down. The default policy is
	// `OrderedReady`, where pods are created in increasing order (pod-0, then
	// pod-1, etc) and the controller will wait until each pod is ready before
	// continuing. When scaling down, the pods are removed in the opposite order.
	// The alternative policy is `Parallel` which will create pods in parallel
	// to match the desired scale without waiting, and on scale down will delete
	// all pods at once.
	// +optional
	podManagementPolicy?: appsv1.#PodManagementPolicyType @go(PodManagementPolicy) @protobuf(6,bytes,opt,casttype=PodManagementPolicyType)

	// updateStrategy indicates the StatefulSetUpdateStrategy that will be
	// employed to update Pods in the StatefulSet when a revision is made to
	// Template.
	// +optional
	updateStrategy?: null | appsv1.#StatefulSetUpdateStrategy @go(UpdateStrategy,*appsv1.StatefulSetUpdateStrategy) @protobuf(7,bytes,opt)
}

// EmbeddedLabelsAnnotations is an embedded subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
// Only labels and annotations are included.
#EmbeddedLabelsAnnotations: {
	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(11,bytes,rep)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(12,bytes,rep)
}

// EmbeddedObjectMeta is an embedded subset of the fields included in k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta.
// Only fields which are relevant to embedded resources are included.
#EmbeddedObjectMeta: {
	// Name must be unique within a namespace. Is required when creating resources, although
	// some resources may allow a client to request the generation of an appropriate name
	// automatically. Name is primarily intended for creation idempotence and configuration
	// definition.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	// +optional
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Namespace defines the space within each name must be unique. An empty namespace is
	// equivalent to the "default" namespace, but "default" is the canonical representation.
	// Not all objects are required to be scoped to a namespace - the value of this field for
	// those objects will be empty.
	//
	// Must be a DNS_LABEL.
	// Cannot be updated.
	// More info: http://kubernetes.io/docs/user-guide/namespaces
	// +optional
	namespace?: string @go(Namespace) @protobuf(3,bytes,opt)

	// Map of string keys and values that can be used to organize and categorize
	// (scope and select) objects. May match selectors of replication controllers
	// and services.
	// More info: http://kubernetes.io/docs/user-guide/labels
	// +optional
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(11,bytes,rep)

	// Annotations is an unstructured key value map stored with a resource that may be
	// set by external tools to store and retrieve arbitrary metadata. They are not
	// queryable and should be preserved when modifying objects.
	// More info: http://kubernetes.io/docs/user-guide/annotations
	// +optional
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(12,bytes,rep)
}

// PodTemplateSpec is an embedded version of k8s.io/api/core/v1.PodTemplateSpec.
// It contains a reduced ObjectMeta.
#PodTemplateSpec: {
	// +optional
	metadata?: null | #EmbeddedObjectMeta @go(EmbeddedObjectMeta,*EmbeddedObjectMeta) @protobuf(1,bytes,opt)

	// Specification of the desired behavior of the pod.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
	// +optional
	spec?: null | corev1.#PodSpec @go(Spec,*corev1.PodSpec) @protobuf(2,bytes,opt)
}

// PersistentVolumeClaim is an embedded version of k8s.io/api/core/v1.PersistentVolumeClaim.
// It contains TypeMeta and a reduced ObjectMeta.
// Field status is omitted.
#PersistentVolumeClaim: {
	metav1.#TypeMeta

	// +optional
	metadata?: #EmbeddedObjectMeta @go(EmbeddedObjectMeta) @protobuf(1,bytes,opt)

	// Spec defines the desired characteristics of a volume requested by a pod author.
	// More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
	// +optional
	spec?: corev1.#PersistentVolumeClaimSpec @go(Spec) @protobuf(2,bytes,opt)
}

// Allows for the configuration of TLS certificates to be used by RabbitMQ. Also allows for non-TLS traffic to be disabled.
#TLSSpec: {
	// Name of a Secret in the same Namespace as the RabbitmqCluster, containing the server's private key & public certificate for TLS.
	// The Secret must store these as tls.key and tls.crt, respectively.
	// This Secret can be created by running `kubectl create secret tls tls-secret --cert=path/to/tls.cert --key=path/to/tls.key`
	secretName?: string @go(SecretName)

	// Name of a Secret in the same Namespace as the RabbitmqCluster, containing the Certificate Authority's public certificate for TLS.
	// The Secret must store this as ca.crt.
	// This Secret can be created by running `kubectl create secret generic ca-secret --from-file=ca.crt=path/to/ca.cert`
	// Used for mTLS, and TLS for rabbitmq_web_stomp and rabbitmq_web_mqtt.
	caSecretName?: string @go(CaSecretName)

	// When set to true, the RabbitmqCluster disables non-TLS listeners for RabbitMQ, management plugin and for any enabled plugins in the following list: stomp, mqtt, web_stomp, web_mqtt.
	// Only TLS-enabled clients will be able to connect.
	disableNonTLSListeners?: bool @go(DisableNonTLSListeners)
}

// A Plugin to enable on the RabbitmqCluster.
// +kubebuilder:validation:Pattern:="^\\w+$"
// +kubebuilder:validation:MaxLength=100
#Plugin: string

// RabbitMQ-related configuration.
#RabbitmqClusterConfigurationSpec: {
	// List of plugins to enable in addition to essential plugins: rabbitmq_management, rabbitmq_prometheus, and rabbitmq_peer_discovery_k8s.
	// +kubebuilder:validation:MaxItems:=100
	additionalPlugins?: [...#Plugin] @go(AdditionalPlugins,[]Plugin)

	// Modify to add to the rabbitmq.conf file in addition to default configurations set by the operator.
	// Modifying this property on an existing RabbitmqCluster will trigger a StatefulSet rolling restart and will cause rabbitmq downtime.
	// For more information on this config, see https://www.rabbitmq.com/configure.html#config-file
	// +kubebuilder:validation:MaxLength:=2000
	additionalConfig?: string @go(AdditionalConfig)

	// Specify any rabbitmq advanced.config configurations to apply to the cluster.
	// For more information on advanced config, see https://www.rabbitmq.com/configure.html#advanced-config-file
	// +kubebuilder:validation:MaxLength:=100000
	advancedConfig?: string @go(AdvancedConfig)

	// Modify to add to the rabbitmq-env.conf file. Modifying this property on an existing RabbitmqCluster will trigger a StatefulSet rolling restart and will cause rabbitmq downtime.
	// For more information on env config, see https://www.rabbitmq.com/man/rabbitmq-env.conf.5.html
	// +kubebuilder:validation:MaxLength:=100000
	envConfig?: string @go(EnvConfig)
}

// The settings for the persistent storage desired for each Pod in the RabbitmqCluster.
#RabbitmqClusterPersistenceSpec: {
	// The name of the StorageClass to claim a PersistentVolume from.
	storageClassName?: null | string @go(StorageClassName,*string)

	// The requested size of the persistent volume attached to each Pod in the RabbitmqCluster.
	// The format of this field matches that defined by kubernetes/apimachinery.
	// See https://pkg.go.dev/k8s.io/apimachinery/pkg/api/resource#Quantity for more info on the format of this field.
	// +kubebuilder:default:="10Gi"
	storage?: null | k8sresource.#Quantity @go(Storage,*k8sresource.Quantity)
}

// Settable attributes for the Service resource.
#RabbitmqClusterServiceSpec: {
	// Type of Service to create for the cluster. Must be one of: ClusterIP, LoadBalancer, NodePort.
	// For more info see https://pkg.go.dev/k8s.io/api/core/v1#ServiceType
	// +kubebuilder:validation:Enum=ClusterIP;LoadBalancer;NodePort
	// +kubebuilder:default:="ClusterIP"
	type?: corev1.#ServiceType @go(Type)

	// Annotations to add to the Service.
	annotations?: {[string]: string} @go(Annotations,map[string]string)
}

// RabbitmqClusterList contains a list of RabbitmqClusters.
#RabbitmqClusterList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)

	// Array of RabbitmqCluster resources.
	items: [...#RabbitmqCluster] @go(Items,[]RabbitmqCluster)
}
