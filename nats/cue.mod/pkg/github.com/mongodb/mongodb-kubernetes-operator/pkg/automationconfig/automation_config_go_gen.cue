// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/mongodb/mongodb-kubernetes-operator/pkg/automationconfig

package automationconfig

import (
	"github.com/stretchr/objx"
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/authentication/scramcredentials"
)

#Mongod:                              #ProcessType & "mongod"
#DefaultMongoDBDataDir:               "/data"
#DefaultDBPort:                       int & 27017
#DefaultAgentLogPath:                 "/var/log/mongodb-mms-automation"
#DefaultAgentMaxLogFileDurationHours: int & 24

// +kubebuilder:object:generate=true
#MemberOptions: {
	votes?:    null | int    @go(Votes,*int)
	priority?: null | string @go(Priority,*string)
	tags?: {[string]: string} @go(Tags,map[string]string)
}

#AutomationConfig: {
	version: int @go(Version)
	processes: [...#Process] @go(Processes,[]Process)
	replicaSets: [...#ReplicaSet] @go(ReplicaSets,[]ReplicaSet)
	auth:        #Auth              @go(Auth)
	prometheus?: null | #Prometheus @go(Prometheus,*Prometheus)

	// TLSConfig and SSLConfig exist to allow configuration of older agents which accept the "ssl" field rather or "tls"
	// only one of these should be set.
	tls?: null | #TLS @go(TLSConfig,*TLS)
	ssl?: null | #TLS @go(SSLConfig,*TLS)
	mongoDbVersions: [...#MongoDbVersionConfig] @go(Versions,[]MongoDbVersionConfig)
	backupVersions: [...#BackupVersion] @go(BackupVersions,[]BackupVersion)
	monitoringVersions: [...#MonitoringVersion] @go(MonitoringVersions,[]MonitoringVersion)
	options: #Options @go(Options)
	roles?: [...#CustomRole] @go(Roles,[]CustomRole)
}

#BackupVersion: {
	baseUrl: string @go(BaseUrl)
}

#MonitoringVersion: {
	hostname: string @go(Hostname)
	name:     string @go(Name)
	baseUrl:  string @go(BaseUrl)
	additionalParams?: {[string]: string} @go(AdditionalParams,map[string]string)
}

#Process: {
	name:                        string       @go(Name)
	disabled:                    bool         @go(Disabled)
	hostname:                    string       @go(HostName)
	args2_6:                     objx.#Map    @go(Args26)
	featureCompatibilityVersion: string       @go(FeatureCompatibilityVersion)
	processType:                 #ProcessType @go(ProcessType)
	version:                     string       @go(Version)
	authSchemaVersion:           int          @go(AuthSchemaVersion)
}

#TLSMode: string // #enumTLSMode

#enumTLSMode:
	#TLSModeDisabled |
	#TLSModeAllowed |
	#TLSModePreferred |
	#TLSModeRequired

#TLSModeDisabled:  #TLSMode & "disabled"
#TLSModeAllowed:   #TLSMode & "allowTLS"
#TLSModePreferred: #TLSMode & "preferTLS"
#TLSModeRequired:  #TLSMode & "requireTLS"

#ProcessType: string // #enumProcessType

#enumProcessType:
	#Mongod

#SystemLog: {
	destination: string @go(Destination)
	path:        string @go(Path)
	logAppend:   bool   @go(LogAppend)
}

#WiredTiger: {
	engineConfig: #EngineConfig @go(EngineConfig)
}

#EngineConfig: {
	cacheSizeGB: float32 @go(CacheSizeGB)
}

#ReplicaSet: {
	"_id": string @go(Id)
	members: [...#ReplicaSetMember] @go(Members,[]ReplicaSetMember)
	protocolVersion: string @go(ProtocolVersion)
	numberArbiters:  int    @go(NumberArbiters)
}

#ReplicaSetMember: {
	"_id":       int                 @go(Id)
	host:        string              @go(Host)
	arbiterOnly: bool                @go(ArbiterOnly)
	horizons?:   #ReplicaSetHorizons @go(Horizons)

	// this is duplicated here instead of using MemberOptions because type of priority
	// is different in AC from the CR(CR don't support float) - hence all the members are declared
	// separately
	votes?:    null | int @go(Votes,*int)
	priority?: float32    @go(Priority)
	tags?: {[string]: string} @go(Tags,map[string]string)
}

#ReplicaSetHorizons: [string]: string

#Auth: {
	// Users is a list which contains the desired users at the project level.
	usersWanted?: [...#MongoDBUser] @go(Users,[]MongoDBUser)
	disabled: bool @go(Disabled)

	// AuthoritativeSet indicates if the MongoDBUsers should be synced with the current list of Users
	authoritativeSet: bool @go(AuthoritativeSet)

	// AutoAuthMechanisms is a list of auth mechanisms the Automation Agent is able to use
	autoAuthMechanisms?: [...string] @go(AutoAuthMechanisms,[]string)

	// AutoAuthMechanism is the currently active agent authentication mechanism. This is a read only
	// field
	autoAuthMechanism: string @go(AutoAuthMechanism)

	// DeploymentAuthMechanisms is a list of possible auth mechanisms that can be used within deployments
	deploymentAuthMechanisms?: [...string] @go(DeploymentAuthMechanisms,[]string)

	// AutoUser is the MongoDB Automation Agent user, when x509 is enabled, it should be set to the subject of the AA's certificate
	autoUser?: string @go(AutoUser)

	// Key is the contents of the KeyFile, the automation agent will ensure this a KeyFile with these contents exists at the `KeyFile` path
	key?: string @go(Key)

	// KeyFile is the path to a keyfile with read & write permissions. It is a required field if `Disabled=false`
	keyfile?: string @go(KeyFile)

	// KeyFileWindows is required if `Disabled=false` even if the value is not used
	keyfileWindows?: string @go(KeyFileWindows)

	// AutoPwd is a required field when going from `Disabled=false` to `Disabled=true`
	autoPwd?: string @go(AutoPwd)
}

#Prometheus: {
	enabled:        bool   @go(Enabled)
	username:       string @go(Username)
	password?:      string @go(Password)
	passwordHash?:  string @go(PasswordHash)
	passwordSalt?:  string @go(PasswordSalt)
	scheme:         string @go(Scheme)
	tlsPemPath:     string @go(TLSPemPath)
	tlsPemPassword: string @go(TLSPemPassword)
	mode:           string @go(Mode)
	listenAddress:  string @go(ListenAddress)
	metricsPath:    string @go(MetricsPath)
}

#CustomRole: {
	role: string @go(Role)
	db:   string @go(DB)
	privileges: [...#Privilege] @go(Privileges,[]Privilege)
	roles: [...#Role] @go(Roles,[]Role)
	authenticationRestrictions?: [...#AuthenticationRestriction] @go(AuthenticationRestrictions,[]AuthenticationRestriction)
}

#Privilege: {
	resource: #Resource @go(Resource)
	actions: [...string] @go(Actions,[]string)
}

#Resource: {
	db?:          null | string @go(DB,*string)
	collection?:  null | string @go(Collection,*string)
	anyResource?: bool          @go(AnyResource)
	cluster?:     bool          @go(Cluster)
}

#AuthenticationRestriction: {
	clientSource: [...string] @go(ClientSource,[]string)
	serverAddress: [...string] @go(ServerAddress,[]string)
}

#MongoDBUser: {
	mechanisms: [...string] @go(Mechanisms,[]string)
	roles: [...#Role] @go(Roles,[]Role)
	user: string @go(Username)
	db:   string @go(Database)
	authenticationRestrictions: [...string] @go(AuthenticationRestrictions,[]string)

	// ScramShaCreds are generated by the operator.
	scramSha256Creds?: null | scramcredentials.#ScramCreds @go(ScramSha256Creds,*scramcredentials.ScramCreds)
	scramSha1Creds?:   null | scramcredentials.#ScramCreds @go(ScramSha1Creds,*scramcredentials.ScramCreds)
}

#Role: {
	role: string @go(Role)
	db:   string @go(Database)
}

#ClientCertificateMode: string // #enumClientCertificateMode

#enumClientCertificateMode:
	#ClientCertificateModeOptional |
	#ClientCertificateModeRequired

#ClientCertificateModeOptional: #ClientCertificateMode & "OPTIONAL"
#ClientCertificateModeRequired: #ClientCertificateMode & "REQUIRED"

#TLS: {
	CAFilePath:            string
	clientCertificateMode: #ClientCertificateMode @go(ClientCertificateMode)
}

#LogRotate: {
	sizeThresholdMB:  int @go(SizeThresholdMB)
	timeThresholdHrs: int @go(TimeThresholdHrs)
}

#ToolsVersion: {
	version: string @go(Version)
	urls: {[string]: [string]: string} @go(URLs,map[string]map[string]string)
}

#Options: {
	downloadBase: string @go(DownloadBase)
}

#VersionManifest: {
	updated: int @go(Updated)
	versions: [...#MongoDbVersionConfig] @go(Versions,[]MongoDbVersionConfig)
}

#BuildConfig: {
	platform:     string @go(Platform)
	url:          string @go(Url)
	gitVersion:   string @go(GitVersion)
	architecture: string @go(Architecture)
	flavor:       string @go(Flavor)
	minOsVersion: string @go(MinOsVersion)
	maxOsVersion: string @go(MaxOsVersion)
	modules: [...string] @go(Modules,[]string)
}

#MongoDbVersionConfig: {
	name: string @go(Name)
	builds: [...#BuildConfig] @go(Builds,[]BuildConfig)
}
