// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/mongodb/mongodb-kubernetes-operator/api/v1

package v1

import (
	"github.com/mongodb/mongodb-kubernetes-operator/pkg/automationconfig"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

#Type: string // #enumType

#enumType:
	#ReplicaSet

#ReplicaSet:        #Type & "ReplicaSet"
_#defaultDBForUser: "admin"

#Phase: string // #enumPhase

#enumPhase:
	#Running |
	#Failed |
	#Pending

#Running:             #Phase & "Running"
#Failed:              #Phase & "Failed"
#Pending:             #Phase & "Pending"
_#defaultPasswordKey: "password"

// Keep in sync with controllers/prometheus.go
_#defaultPrometheusPort: 9216

_#defaultMode: #AuthMode & "SCRAM-SHA-256"

_#defaultClusterDomain: "cluster.local"

// MongoDBCommunitySpec defines the desired state of MongoDB
#MongoDBCommunitySpec: {
	// Members is the number of members in the replica set
	// +optional
	members: int @go(Members)

	// Type defines which type of MongoDB deployment the resource should create
	// +kubebuilder:validation:Enum=ReplicaSet
	type: #Type @go(Type)

	// Version defines which version of MongoDB will be used
	version?: string @go(Version)

	// Arbiters is the number of arbiters to add to the Replica Set.
	// It is not recommended to have more than one arbiter per Replica Set.
	// More info: https://www.mongodb.com/docs/manual/tutorial/add-replica-set-arbiter/
	// +optional
	arbiters: int @go(Arbiters)

	// FeatureCompatibilityVersion configures the feature compatibility version that will
	// be set for the deployment
	// +optional
	featureCompatibilityVersion?: string @go(FeatureCompatibilityVersion)

	// ReplicaSetHorizons Add this parameter and values if you need your database
	// to be accessed outside of Kubernetes. This setting allows you to
	// provide different DNS settings within the Kubernetes cluster and
	// to the Kubernetes cluster. The Kubernetes Operator uses split horizon
	// DNS for replica set members. This feature allows communication both
	// within the Kubernetes cluster and from outside Kubernetes.
	// +optional
	replicaSetHorizons?: #ReplicaSetHorizonConfiguration @go(ReplicaSetHorizons)

	// Security configures security features, such as TLS, and authentication settings for a deployment
	// +required
	security: #Security @go(Security)

	// Users specifies the MongoDB users that should be configured in your deployment
	// +required
	users: [...#MongoDBUser] @go(Users,[]MongoDBUser)

	// +optional
	statefulSet?: #StatefulSetConfiguration @go(StatefulSetConfiguration)

	// AgentConfiguration sets options for the MongoDB automation agent
	// +optional
	agent?: #AgentConfiguration @go(AgentConfiguration)

	// AdditionalMongodConfig is additional configuration that can be passed to
	// each data-bearing mongod at runtime. Uses the same structure as the mongod
	// configuration file: https://www.mongodb.com/docs/manual/reference/configuration-options/
	// +kubebuilder:validation:Type=object
	// +optional
	// +kubebuilder:pruning:PreserveUnknownFields
	// +nullable
	additionalMongodConfig?: #MongodConfiguration @go(AdditionalMongodConfig)

	// AutomationConfigOverride is merged on top of the operator created automation config. Processes are merged
	// by name. Currently Only the process.disabled field is supported.
	automationConfig?: null | #AutomationConfigOverride @go(AutomationConfigOverride,*AutomationConfigOverride)

	// Prometheus configurations.
	// +optional
	prometheus?: null | #Prometheus @go(Prometheus,*Prometheus)
}

// ReplicaSetHorizonConfiguration holds the split horizon DNS settings for
// replica set members.
#ReplicaSetHorizonConfiguration: [...automationconfig.#ReplicaSetHorizons]

// CustomRole defines a custom MongoDB role.
#CustomRole: {
	// The name of the role.
	role: string @go(Role)

	// The database of the role.
	db: string @go(DB)

	// The privileges to grant the role.
	privileges: [...#Privilege] @go(Privileges,[]Privilege)

	// An array of roles from which this role inherits privileges.
	// +optional
	roles: [...#Role] @go(Roles,[]Role)

	// The authentication restrictions the server enforces on the role.
	// +optional
	authenticationRestrictions?: [...#AuthenticationRestriction] @go(AuthenticationRestrictions,[]AuthenticationRestriction)
}

#Prometheus: {
	// Port where metrics endpoint will bind to. Defaults to 9216.
	// +optional
	port?: int @go(Port)

	// HTTP Basic Auth Username for metrics endpoint.
	username: string @go(Username)

	// Name of a Secret containing a HTTP Basic Auth Password.
	passwordSecretRef: #SecretKeyReference @go(PasswordSecretRef)

	// Indicates path to the metrics endpoint.
	// +kubebuilder:validation:Pattern=^\/[a-z0-9]+$
	metricsPath?: string @go(MetricsPath)

	// Name of a Secret (type kubernetes.io/tls) holding the certificates to use in the
	// Prometheus endpoint.
	// +optional
	tlsSecretKeyRef?: #SecretKeyReference @go(TLSSecretRef)
}

// Privilege defines the actions a role is allowed to perform on a given resource.
#Privilege: {
	resource: #Resource @go(Resource)
	actions: [...string] @go(Actions,[]string)
}

// Resource specifies specifies the resources upon which a privilege permits actions.
// See https://www.mongodb.com/docs/manual/reference/resource-document for more.
#Resource: {
	// +optional
	db?: null | string @go(DB,*string)

	// +optional
	collection?: null | string @go(Collection,*string)

	// +optional
	cluster?: bool @go(Cluster)

	// +optional
	anyResource?: bool @go(AnyResource)
}

// AuthenticationRestriction specifies a list of IP addresses and CIDR ranges users
// are allowed to connect to or from.
#AuthenticationRestriction: {
	clientSource: [...string] @go(ClientSource,[]string)
	serverAddress: [...string] @go(ServerAddress,[]string)
}

// AutomationConfigOverride contains fields which will be overridden in the operator created config.
#AutomationConfigOverride: {
	processes: [...#OverrideProcess] @go(Processes,[]OverrideProcess)
}

// OverrideProcess contains fields that we can override on the AutomationConfig processes.
#OverrideProcess: {
	name:     string @go(Name)
	disabled: bool   @go(Disabled)
}

// StatefulSetConfiguration holds the optional custom StatefulSet
// that should be merged into the operator created one.
#StatefulSetConfiguration: {
	// +kubebuilder:pruning:PreserveUnknownFields
	spec: #StatefulSetSpecWrapper @go(SpecWrapper)
}

#LogLevel: string // #enumLogLevel

#enumLogLevel:
	#LogLevelDebug

#LogLevelDebug: #LogLevel & "DEBUG"
#LogLevelInfo:  "INFO"
#LogLevelWarn:  "WARN"
#LogLevelError: "ERROR"
#LogLevelFatal: "FATAL"

#AgentConfiguration: {
	// +optional
	logLevel: #LogLevel @go(LogLevel)

	// +optional
	maxLogFileDurationHours: int @go(MaxLogFileDurationHours)
}

#StatefulSetSpecWrapper: _

// MongodConfiguration holds the optional mongod configuration
// that should be merged with the operator created one.
//
// The CRD generator does not support map[string]interface{}
// on the top level and hence we need to work around this with
// a wrapping struct.
#MongodConfiguration: _

#MongoDBUser: {
	// Name is the username of the user
	name: string @go(Name)

	// DB is the database the user is stored in. Defaults to "admin"
	// +optional
	// +kubebuilder:validation:Optional
	// +kubebuilder:default:=admin
	db?: string @go(DB)

	// PasswordSecretRef is a reference to the secret containing this user's password
	passwordSecretRef: #SecretKeyReference @go(PasswordSecretRef)

	// Roles is an array of roles assigned to this user
	roles: [...#Role] @go(Roles,[]Role)

	// ScramCredentialsSecretName appended by string "scram-credentials" is the name of the secret object created by the mongoDB operator for storing SCRAM credentials
	// These secrets names must be different for each user in a deployment.
	// +kubebuilder:validation:Pattern=^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$
	scramCredentialsSecretName: string @go(ScramCredentialsSecretName)

	// ConnectionStringSecretName is the name of the secret object created by the operator which exposes the connection strings for the user.
	// If provided, this secret must be different for each user in a deployment.
	// +optional
	connectionStringSecretName: string @go(ConnectionStringSecretName)
}

// SecretKeyReference is a reference to the secret containing the user's password
#SecretKeyReference: {
	// Name is the name of the secret storing this user's password
	name: string @go(Name)

	// Key is the key in the secret storing this password. Defaults to "password"
	// +optional
	key: string @go(Key)
}

// Role is the database role this user should have
#Role: {
	// DB is the database the role can act on
	db: string @go(DB)

	// Name is the name of the role
	name: string @go(Name)
}

#Security: {
	// +optional
	authentication: #Authentication @go(Authentication)

	// TLS configuration for both client-server and server-server communication
	// +optional
	tls: #TLS @go(TLS)

	// User-specified custom MongoDB roles that should be configured in the deployment.
	// +optional
	roles?: [...#CustomRole] @go(Roles,[]CustomRole)
}

// TLS is the configuration used to set up TLS encryption
#TLS: {
	enabled: bool @go(Enabled)

	// Optional configures if TLS should be required or optional for connections
	// +optional
	optional: bool @go(Optional)

	// CertificateKeySecret is a reference to a Secret containing a private key and certificate to use for TLS.
	// The key and cert are expected to be PEM encoded and available at "tls.key" and "tls.crt".
	// This is the same format used for the standard "kubernetes.io/tls" Secret type, but no specific type is required.
	// Alternatively, an entry tls.pem, containing the concatenation of cert and key, can be provided.
	// If all of tls.pem, tls.crt and tls.key are present, the tls.pem one needs to be equal to the concatenation of tls.crt and tls.key
	// +optional
	certificateKeySecretRef: corev1.#LocalObjectReference @go(CertificateKeySecret)

	// CaCertificateSecret is a reference to a Secret containing the certificate for the CA which signed the server certificates
	// The certificate is expected to be available under the key "ca.crt"
	// +optional
	caCertificateSecretRef?: null | corev1.#LocalObjectReference @go(CaCertificateSecret,*corev1.LocalObjectReference)

	// CaConfigMap is a reference to a ConfigMap containing the certificate for the CA which signed the server certificates
	// The certificate is expected to be available under the key "ca.crt"
	// This field is ignored when CaCertificateSecretRef is configured
	// +optional
	caConfigMapRef?: null | corev1.#LocalObjectReference @go(CaConfigMap,*corev1.LocalObjectReference)
}

#Authentication: {
	// Modes is an array specifying which authentication methods should be enabled.
	modes: [...#AuthMode] @go(Modes,[]AuthMode)

	// +optional
	// +kubebuilder:default:=true
	// +nullable
	ignoreUnknownUsers?: null | bool @go(IgnoreUnknownUsers,*bool)
}

// +kubebuilder:validation:Enum=SCRAM;SCRAM-SHA-256;SCRAM-SHA-1
#AuthMode: string // #enumAuthMode

#enumAuthMode:
	_#defaultMode

// MongoDBCommunityStatus defines the observed state of MongoDB
#MongoDBCommunityStatus: {
	mongoUri:                            string @go(MongoURI)
	phase:                               #Phase @go(Phase)
	version?:                            string @go(Version)
	currentStatefulSetReplicas:          int    @go(CurrentStatefulSetReplicas)
	currentMongoDBMembers:               int    @go(CurrentMongoDBMembers)
	currentStatefulSetArbitersReplicas?: int    @go(CurrentStatefulSetArbitersReplicas)
	currentMongoDBArbiters?:             int    @go(CurrentMongoDBArbiters)
	message?:                            string @go(Message)
}

// MongoDBCommunity is the Schema for the mongodbs API
// +kubebuilder:subresource:status
// +kubebuilder:resource:path=mongodbcommunity,scope=Namespaced,shortName=mdbc,singular=mongodbcommunity
// +kubebuilder:printcolumn:name="Phase",type="string",JSONPath=".status.phase",description="Current state of the MongoDB deployment"
// +kubebuilder:printcolumn:name="Version",type="string",JSONPath=".status.version",description="Version of MongoDB server"
// +kubebuilder:metadata:annotations="service.binding/type=mongodb"
// +kubebuilder:metadata:annotations="service.binding/provider=community"
// +kubebuilder:metadata:annotations="service.binding=path={.metadata.name}-{.spec.users[0].db}-{.spec.users[0].name},objectType=Secret"
// +kubebuilder:metadata:annotations="service.binding/connectionString=path={.metadata.name}-{.spec.users[0].db}-{.spec.users[0].name},objectType=Secret,sourceKey=connectionString.standardSrv"
// +kubebuilder:metadata:annotations="service.binding/username=path={.metadata.name}-{.spec.users[0].db}-{.spec.users[0].name},objectType=Secret,sourceKey=username"
// +kubebuilder:metadata:annotations="service.binding/password=path={.metadata.name}-{.spec.users[0].db}-{.spec.users[0].name},objectType=Secret,sourceKey=password"
#MongoDBCommunity: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta      @go(ObjectMeta)
	spec?:     #MongoDBCommunitySpec   @go(Spec)
	status?:   #MongoDBCommunityStatus @go(Status)
}

// MongoDBCommunityList contains a list of MongoDB
#MongoDBCommunityList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#MongoDBCommunity] @go(Items,[]MongoDBCommunity)
}
